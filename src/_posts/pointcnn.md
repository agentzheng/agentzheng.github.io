---
title: PointCNN 论文翻译解析 
date: 2018-05-28 15:25:46
tags: 
- 深度学习
- 点云处理
---
卷积神经网络在二维图像的应用已经较为成熟了，但 CNN 在三维空间上，尤其是点云这种无序集的应用现在研究得尤其少。山东大学近日公布的一项研究提出的 PointCNN 可以让 CNN 在点云数据的处理刷新了多项深度学习任务的纪录。由于项目需要，我对PointCNN论文的核心部分做了翻译及部分解析，希望能够帮助大家更好地学习理解PointCNN。
<!-- more -->

## 概述
![Fig1](https://s1.ax2x.com/2018/05/28/7BhmG.png)

如Fig1，传统的卷积作用在二维图像上。在图像中数据是结构化存储的。直接对图像应用卷积核 就能从这种二维空间结构中获取信息。而点云数据是无序集，如果直接使用卷积会出现(1)中ii,iii,iv的情况
![直接卷积](https://s1.ax2x.com/2018/05/28/7BvZn.png)
如上图所示，由于卷积操作的性质，在所有情况下$f_{ii}$与$f_{iii}$的计算结果是相等的，而$f_{iii}$与$f_{iv}$的计算结果在大多数情况是不相等的。很显然，直接卷积会导致形状信息的变形并且使卷积结果对于顺序敏感。

而PointCNN里采用的是这样的策略：

从前一层的数据中取K个候选点$(p_1,p_2,...p_K)$，使用MLP(多层感知器)来学习一个$K×K$ 的变换矩阵（X-transformation，X变换）也就是说$X=MLP(p_1,p_2,...p_K)$，然后用它同时对输入特征进行加权和置换，最后对经过变换的特征应用典型卷积。我们称这个过程为X-Conv，它是PointCNN的基本构建模块。

对(1)中的 (ii),(iii),和(iii)的X-conv可以表示成这样：
![1527487472886](https://s1.ax2x.com/2018/05/28/7ByNE.png)

在这里 **这些 X变换** 是4×4的矩阵，因为Fig1中K=4。

因为$X_{ii}$，$X_{iii}$是从不同形状的点集中学习得到的变换，它们可以对不同的点对应的进行加权，因此使得$f_{ii}$不再等于$f_{iii}$。

对于$iii$和$iv$，如果我们通过学习使得$X_{iii}=X_{iv}×\Pi$ ，$\Pi $ 是一个排序矩阵用来将$(c,a,b,d)$变成$(a,b,c,d)$,就可以实现$f_{iii}\equiv f_{iv}$。

从Fig1 中的例子分析可以看出，当X-Conv 搭配 **<u>理想的X变换</u>** 时，能够在考虑点集形状的同时，不依赖于输入点的顺序。

在实验中，我们发现学习到的X变换并不是很理想，特别是在排序等价性方面。

尽管如此，使用X-Conv构建的PointCNN仍然明显优于直接对点云应用传统卷积，相比为点云数据设计的最先进的非卷积神经网络（例如，PointNet ++）有着相近甚至更好的表现。



 ## 分层卷积
类比图像CNN的卷积，图像CNN的输入是$R_1×R_1×C_1$，而卷积核的大小是$K×K×C_1×C_2$,从前一层$F_1$中大小为$K×K× C_1$的区域生成$F_2$形状大小为$R_2×R_2×C_2$的特征。

而PointCNN的输入点集$F_1 = \{ ({p_{1,i} , f_{1,i} ) : i = 1,2,..., N_1}\}$， 其中$\{p_{1,i}:p_{1,i}\in R^D\}$是点的$D$维坐标(这里是三维)，$\{f_{1,i}:f_{1,i}\in R^{C_1}\}$是点集对应的特征。

对$F1$应用 X-Conv（就是带X变换的卷积）得到$F_2 =\{(p_{2,i} , f_{2,i} ) : f_{2,i} ∈ R^{C_2} , i =1, 2, ..., N_2\}$。$\{p_ {2,i}\}$是$\{p_ {1,i} \}$的一个代表点集合。但请注意，$\{p_ {2，i}\}$不需要是$\{p_ {1,i} \}$的真子集。

若$N_2<N_1$, $C_2>C_1$， 则随着一层一层的映射，点的数量会越来越少，但是每个点的特征却越来越丰富。

![Fig2](https://s1.ax2x.com/2018/05/28/7BLWS.png) 

Fig2 上半部分是图像的CNN，通过conv提取特征，通过池化降采样。

下半部分是PointCNN，通过X-Conv提取特征，通过降采样削减样本数量。

从 $F_1$中选取代表点集$F_2$的方法，暂时的实现是：
- 对分类问题：$p_2$是$p_1$的随机下采样。
- 对语义分割问题：$p_2$是$p_1$的最远点采样。  

## X-Conv算子
为了实现与图像卷积类似的空间局部相关性，X-Conv只作用于局部区域。

在$F_2$中的任何一个点$p$, 其在$F_1$中的$K$近邻点集称作$N$。

所以每一个X-Conv针对$p$的输入是$S = \{(p_i , f_i ) : p_i ∈ N\}$, $S$为一个无序集合。不失一般性，$S$可以分开表示为$K×D$的坐标矩阵$P = (p_1,p_1, ...,p_K )^T$ 和$K×C_1$的特征矩阵$F = (f_1, f_2, ..., f_K)^T$。所以X-Conv的参数有$K × (C_1 + C_δ ) × C_2$个。

### X-Conv 算子

![算法](https://s1.ax2x.com/2018/05/28/7Bcb2.png)

1. $P′ \gets P−p$     将点集$P$变换到以$p$点为中心的局部坐标系

2. $F_δ ← MLP_δ (P′)$ 逐点应用$MLP_δ$,将$P'$从$R^3$坐标空间映射到$R^{C_\delta}$特征空间

3. $F_∗ ← [F_δ , F]$   把$F_\delta$ 和$F$拼接起来,$F_*$ 是一个 $K × (C_δ + C_1)$ 矩阵

4. $X← MLP(P′)$   用$MLP$学习$P'$获得$K×K$的X变换矩阵

5. $F_X ← X × F_∗$   应用X变换矩阵加权置换 $F_*$

6. $F_p ←Conv(K, F_X)​$ 做卷积

   

   ![Fig3](https://s1.ax2x.com/2018/05/28/7BrKa.png)

## PointCNN 架构

从图2中我们可以看出，图像CNN中的卷积层和PointCNN中的X-Conv层仅在两个方面有所不同：

1. 提取局部区域的方式(图像CNN中的K×K区域 与 PointCNN中代表点周围的K个邻近点)
2. 对于局部区域的信息学习方式(图像CNN的Conv 与PointCNN中的X-Conv)。

除此之外，与图像CNN中的卷积层相比，用X-Conv层组装的深度网络没有多大区别。

![Fig4](https://s1.ax2x.com/2018/05/28/7BCoz.png)

### 分类任务

在Fig4(a)中，我们展示了一个简单的PointCNN，带有两个X-Conv层，逐渐将输入点(带有或不带有特征)转换为较少的代表点，但每个点都具有更丰富的特征。
在第二个X-Conv层之后，只剩下一个代表点，它从前一层的所有点接收信息。

在PointCNN中，我们可以将每个代表点的**感受野**粗略地定义为比率K / N，其中K是相邻点的数目，N是前一层中的点的数目。通过这个定义，最后一个剩下的点“看到”来自上一层的所有点，因此具有接受域1.0  -- 它具有整个形状的全局视图，因此它的特征为形状的语义理解提供了信息。
我们可以在最后一个X -conv层输出的顶部增加一些完全连接的层，然后是用于训练网络的损失。
请注意，Fig4(a)中PointCNN的顶层X-Conv层的训练样本数量迅速下降，使得彻底训练顶层X-Conv层的效率很差。

为了解决这个问题，我们提出了Fig4(b)中的PointCNN，其中更多的代表点被保留在X-Conv层中。但是，我们希望保持网络的深度，同时保持感受野的增长率，使得更深层的代表点“看到”整个形状的越来越大的部分。我们通过将图像CNN中的[空洞卷积](https://www.zhihu.com/question/54149221)思想应用到PointCNN中来实现这一目标。我们可以不总是以$K$个邻近点作为输入，而是从K×D个邻近点对K个输入点进行均匀采样，其中D是膨胀率。在这种情况下，感受野从$K / N$增加到$(K×D)/N$，而不增加实际相邻点数量，也不增加内核大小。

在Fig4(b)中的PointCNN的第二个X-Conv层中，使用了膨胀率D = 2，因此剩下的所有四个代表点“看到”整个形状，并且它们都适合做出预测。请注意，通过这种方式，与Fig4(a)的PointCNN相比，我们可以更彻底地训练顶层X-Conv层，因为网络涉及更多的连接。在测试时间内，多个代表点的输出在sof tmax之前进行平均，以稳定预测结果。这种设计非常类似于网络中[Lin et al]的网络。我们的分类任务使用的是密度更高的PointCNN(Fig4(b))。


### 分割任务

对于分割任务，需要高分辨率逐点输出，这可以通过在Conv-[DeConv](https://www.zhihu.com/question/43609045)之后构建PointCNN来实现[Noh et al. 2015]架构，DeConv部分负责将全局信息传播到高分辨率预测中(见Fig4(c))。

请注意，PointCNN分段网络中的“Conv”和“DeConv”都是相同的X-Conv算子。对于“DeConv”图层，与“Conv”图层唯一的区别在于，输出中的点数比输入点中的点数多，但特征通道少。“DeConv”层的更高分辨率点从早期的“Conv”层转发，遵循U-Net的设计[Ronneberger et al.2015年]。

$ELU$ [Clevert et al. 2016]是PointCNN中使用的非线性激活函数，因为我们发现它比ReLU更稳定并且性能更好些。在$P'$，$F_p$和FC层输出（除了最后的FC层的输出）上应用**Batch Normalization** [loffe和Szegedy 2015]以减少**内部协变量偏移（Internal covariate shift）**。要注意，**Batch Normalization**不应该应用于$MLP_δ$和$MLP$，因为$F_*$和$X$，特别是$X$，对于特定代表点来说应该是的相当具体的。对于算法1第6行的Conv，可用[分离卷积(Separable convolution )](https://zhuanlan.zhihu.com/p/29367273)替代传统卷积来减少参数数量和计算量。在PointCNN的训练中，我们使用ADAM优化器，初始学习率为0.01。

在最后完全连接的层之前施加Dropout以减少过拟合。我们还采用了Qi等人的“子体积监督（Subvolume supervision）”理念来解决过拟合问题。在最后的X-Conv层中，**感受野** 被设置为小于1，使得最后的X-Conv层中的代表点仅“看到”部分信息。在训练时促使网络更加深入了解局部信息，并在测试时表现更好。

在本文中，PointCNN用分类任务的简单前馈网络和简单的前馈图层以及分割网络中的跳跃链接来演示。然而，由于暴露于其输入和输出层的接口X-Conv与Conv非常相似，我们认为许多来自图像CNN的先进神经网络技术可以用于X-Conv，比如说循环PointCNN。我们将在未来的工作中沿着这些方向展开探索。

**数据增强**  对于X-Conv中的参数的训练，显然，如果相邻点对于特定代表点始终是相同顺序的相同集合，是很不利的。为了提高可推广性，我们提出**随机抽样**和**缩减输入点**，使得相邻点集和顺序可能因批次不同而不同。为了训练以N个点为输入的模型，应有$\boldsymbol N(N,{(N / 8)}^2)$个点用于训练，其中$\boldsymbol N$表示高斯分布。我们发现这一策略对于PointCNN的训练至关重要。



## 致谢

- [PointCNN 原始论文](https://arxiv.org/abs/1801.07791 )
- [PointCNN 论文阅读笔记](https://blog.csdn.net/qq_15602569/article/details/79560614)
- [CopyTranslator](https://github.com/elliottzheng/CopyTranslator) 提供翻译辅助。

上述翻译及解析 由于本人知识水平有限，难免有些错漏,还望各位在评论指出，必定及时改正。

