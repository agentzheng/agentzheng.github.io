(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{347:function(e,n,t){"use strict";t.r(n);var r=t(1),a=Object(r.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("对图像进行卷积是图像处理的基本操作，最近在研究图像滤波，经常要用到自定义卷积，所以实现了一下\n")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('#include "opencv2/imgproc/imgproc.hpp"\n#include "opencv2/highgui/highgui.hpp"\n\nusing namespace cv;\n\nMat get_blur_kernel(int kernel_size);//获得归一化滤波的卷积核\n\nint main(int argc, char ** argv)\n{\n    Mat src, dst;\n    Point anchor;\n    double delta;\n    int ddepth;\n    int kernel_size = 5;\n    // 生成一个掩模核 大小为kernel_size*kernel_size,这里我们用归一化块滤波的卷积核做示例\n    Mat kernel = get_blur_kernel(kernel_size);\n    // 载入一张图片\n    src = imread("a.jpg");\n    if (!src.data)\n        return -1;\n\n    // 创建窗口\n    imshow("before",src);\n    waitKey(500);\n    // 初始化滤波器参数\n    anchor = Point(-1, -1);\n    delta = 0;\n    ddepth = -1;\n    //将核设置好之后，使用函数 filter2D 就可以生成滤波器：\n    filter2D(src, dst, ddepth, kernel, anchor, delta, BORDER_DEFAULT);\n\n    imshow("after", dst);\n    waitKey(0);\n    return 0;\n}\n\n//生成归一化滤波的卷积核,通过对kernel.ptr(i)[j]的操作来进行\nMat get_blur_kernel(int kernel_size)\n{\n    Mat kernel = (Mat_<float>(kernel_size, kernel_size));\n    for (int i = 0; i < kernel_size; i++)\n    {\n        for (int j = 0; j < kernel_size; j++)\n            kernel.ptr<float>(i)[j] = 1.0 / (kernel_size*kernel_size);\n    }\n    return kernel;\n}\n')])])]),t("p",[e._v("卷积核"),t("code",[e._v("kernel")]),e._v("其实也是一个"),t("code",[e._v("Mat")]),e._v("对象，我们可以通过"),t("code",[e._v("kernel.ptr(i)[j]")]),e._v("实现对矩阵元素的直接操作，将核设置好之后，使用OpenCV提供的函数 "),t("code",[e._v("filter2D")]),e._v(" 就可以生成滤波器：")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("filter2D(src, dst, ddepth, kernel, anchor, delta, BORDER_DEFAULT);\n")])])]),t("p",[e._v("其中各参数含义如下：")]),e._v(" "),t("div",{staticClass:"language-CPP extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[e._v("src "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 源图像\ndst "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 目标图像\nddepth "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" dst 的深度。若为负值（如 "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(" ），则表示其深度与源图像相等。\nkernel "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 用来遍历图像的核\nanchor "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 核的锚点的相对位置，其中心点默认为"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" 。\ndelta "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 在卷积过程中，该值会加到每个像素上。默认情况下，这个值为 "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v(" 。\nBORDER_DEFAULT "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" 这里我们保持其默认值，更多细节将在其他教程中详解\n")])])]),t("p",[e._v("只需改变卷积核，我们就可以使用类似的方法创造自定义滤波了。")])])},[],!1,null,null,null);n.default=a.exports}}]);