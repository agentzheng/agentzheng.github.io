(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{347:function(t,v,n){"use strict";n.r(v);var r=n(1),s=Object(r.a)({},function(){var t=this,v=t.$createElement,n=t._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("​\t给定空间长方体的八个顶点坐标，求取长宽高对应向量的方法。")]),t._v(" "),n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),n("p",[t._v("​\t最近有一个需求，给定OBB(Orient Bounding Box,最小包围盒)的八个顶点后，这八个顶点是无序的，我们要找出其长，宽，高对应的向量。")]),t._v(" "),n("h2",{attrs:{id:"算法描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法描述","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法描述")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("首先，定义：\n长为长方体的最长边，宽高为较短的两条边。")])]),t._v(" "),n("li",[n("p",[t._v("算法描述")])]),t._v(" "),n("li",[n("p",[t._v("随便选取八个顶点中的一个,在本算法，初始顶点的选取并没有什么限制，为了下面表示方便，我们直接选取V"),n("sub",[t._v("7")]),t._v("。")])]),t._v(" "),n("li",[n("p",[t._v("令V"),n("sub",[t._v("7")]),t._v(" 与其他七个顶点V"),n("sub",[t._v("j")]),t._v(" (j∈[0,6])分别相差，得到向量 "),n("strong",[t._v("D"),n("sub",[t._v("j")])]),t._v("(j∈[0,6]);")])]),t._v(" "),n("li",[n("p",[t._v("对"),n("strong",[t._v("D")]),t._v("按照向量模进行升序排序,得到"),n("strong",[t._v("N")]),t._v("，**N"),n("sub",[t._v("0")]),t._v("**模最小，**N"),n("sub",[t._v("6")]),t._v("**模最大。")])]),t._v(" "),n("li",[n("p",[t._v("那么模最小的两个向量"),n("strong",[t._v("N"),n("sub",[t._v("0")])]),t._v(","),n("strong",[t._v("N"),n("sub",[t._v("1")])]),t._v(",这两个向量对应的就是长方体的宽和高。")])]),t._v(" "),n("li",[n("p",[t._v("设"),n("strong",[t._v("L")]),t._v("="),n("strong",[t._v("N"),n("sub",[t._v("0")])]),t._v("-"),n("strong",[t._v("N"),n("sub",[t._v("1")])]),t._v(" (向量减法)，比较"),n("strong",[t._v("L")]),t._v("和"),n("strong",[t._v("N"),n("sub",[t._v("2")]),n("strong",[t._v("的模,若|"),n("strong",[t._v("N"),n("sub",[t._v("2")])]),t._v("<|"),n("strong",[t._v("L")]),t._v("|(或者差异较大),那么")]),t._v("D"),n("sub",[t._v("2")])]),t._v(" 即为长方体的长，若|"),n("strong",[t._v("N"),n("sub",[t._v("2")])]),t._v("|=|"),n("strong",[t._v("L")]),t._v("|或者是二者非常接近，那么我们认为"),n("strong",[t._v("D"),n("sub",[t._v("2")])]),t._v(" 和"),n("strong",[t._v("L")]),t._v("相等，那么**D"),n("sub",[t._v("3")]),t._v("**就是长方体的长")])])]),t._v(" "),n("h2",{attrs:{id:"算法实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法实现")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("bool compareNorm(Eigen::Vector3d i,Eigen::Vector3d j)\n{\n    return i.norm() < j.norm();\n}\nclass cuboid\n{\n    private Eigen::Vector3d length;\n    private Eigen::Vector3d height;\n    private Eigen::Vector3d width;\n\n    void computeNormals(std::vector<Eigen::Vector3d>& vertices)//八个顶点\n    {\n        assert(vertices.size() == 8);\n        std::vector<Eigen::Vector3d> N;\n        for (int i = 0; i < 7; i++)\n        {\n            N.push_back(vertices[i] - vertices[7]);\n        }\n        std::sort(tris.begin(), tris.end(), compareNorm);//对这些向量按照模进行升序排序\n\n        width = N[0]; //最短的那两个向量肯定一个是宽，一个是高\n        height = N[1];\n\n        //面对角线\n        Eigen::Vector3d L = width-height;\n\n        //这边判断第三短的向量到底是面对角线还是长，\n        //如果面对角线比第三短的向量长，那么第三短的向量就是 长，如果没有的话 第四短才是 长\n        length = L.norm() - tris[2].norm() > 0.01 ? tris[2] : tris[3];\n    }\n}\n")])])])])},[],!1,null,null,null);v.default=s.exports}}]);