(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{349:function(t,n,o){"use strict";o.r(n);var r=o(1),e=Object(r.a)({},function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("做数据结构的图的作业，感觉每次都要自己去管理动态二维数组，就特地封装了一个矩阵类，实现了一些基本的接口。")]),t._v(" "),o("p",[t._v("今天在编辑博客的时候又想到说感觉用new 和delete 会限制到这个类的使用，但是又想到要用C风格的malloc 和free ，决定放弃治疗。")]),t._v(" "),o("p",[t._v("看到知乎上一位程序员在头文件中使用了"),o("strong",[t._v("using namespace std;")]),t._v(" 被批评了，我感觉很害怕，赶快过来看看我写的代码有没有，还好没有，哈哈，代码还是得再三推敲啊。")]),t._v(" "),o("p",[t._v("实际上"),o("strong",[t._v("using namespace std;")]),t._v(" 是很经常会使用到的，但是，你在头文件，不知不觉地给人家引入了一个命名空间，可能会带来的各种潜在问题。因此最好不要这么做。")]),t._v(" "),o("p",[t._v("今天改了个名字，然后用fill()函数来批量赋初值，效率高了好多。醉了")]),t._v(" "),o("div",{staticClass:"language-c++ extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('/*\nName：Matrix\nAuther：Elliott Zheng\nDate: 2017.12.8\nModified date：2018.1.16\n一个很基础的矩阵类，不带任何矩阵操作方法，只能访问矩阵元素，隐藏复杂的指针，帮你省去内存管理这一步，做邻接矩阵的题目应该比较方便\n*/\n#pragma once\n#include<iostream>\n\ntemplate<class Type>\nclass Matrix\n{\nprivate:\n\tType * * pointer;\n\tint rows;\n\tint cols;\n\n\n\tvoid clean()\n\t{\n\t\tif (!pointer)\n\t\t\treturn;\n\t\tfor (int i = 0; i < rows; i++)\n\t\t\tdelete[] pointer[i];\n\t\tdelete[] pointer;\n\t}\n\npublic:\n\t// 行数，列数, 把整个矩阵初始化为一个值\n\tMatrix(int row, int col) :pointer(NULL)\n\t{\n\t\tResize(row, col);\n\t}\n\t//额外参数ori是将所有元素置为同一值\n\tMatrix(int row, int col, Type ori) :pointer(NULL)\n\t{\n\t\tResize(row, col);\n\t\tSetAllTo(ori);\n\t}\n\n\t//拷贝构造函数\n\tMatrix(Matrix& other) :pointer(NULL)\n\t{\n\t\tCopy(other);\n\t}\n\n\t//转移构造函数\n\tMatrix(Matrix&& other) :rows(other.rows),cols(other.cols)\n\t{\n\t\tpointer = other.pointer;\n\t\tother.pointer = NULL;\n\t}\n\n\t//拷贝other\n\tvoid Copy(Matrix& other)\n\t{\n\t\tif (&other == this)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tclean();\n\t\trows = other.rows;\n\t\tcols = other.cols;\n\t\tpointer = new   int*[rows];\n\t\tfor (int i = 0; i<rows; i++)\n\t\t{\n\t\t\tpointer[i] = new   int[cols];\n\t\t\tfor (int j = 0; j < cols; j++)\n\t\t\t{\n\t\t\t\tpointer[i][j] = other.pointer[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//行数，列数，还有一个可选参数初值\n\tvoid Resize(int row, int col)\n\t{\n\t\tclean();\n\t\tif (row <= 0 || col <= 0)\n\t\t{\n\t\t\tstd::cerr << "ERROR:你输入的行数或者列数不对，没有意义,已自动置为1" << std::endl;\n\t\t}\n\t\trows = row <= 0 ? 1 : row;\n\t\tcols = col <= 0 ? 1 : col;\n\t\t//防止出现说行数列数为o 或负数\n\t\tpointer = new   int*[rows];\n\t\tfor (int i = 0; i<rows; i++)\n\t\t\tpointer[i] = new  int[cols];\n\t}\n\n\t//行数，列数，初值\n\tvoid Resize(int row, int col, Type ori)\n\t{\n\t\tResize(row, col);\n\t\tSetAllTo(ori);\n\t}\n\n\t//将所有元素设置为ori\n\tvoid SetAllTo(Type ori)\n\t{\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tfill(pointer[i], pointer[i] + cols, ori);\n\t\t}\n\t}\n\n\tint  get_rows()\n\t{\n\t\treturn rows;\n\t}\n\n\tint  get_cols()\n\t{\n\t\treturn cols;\n\t}\n\n\t//比较不推荐，但是你懂我意思吧，其实如果你想要程序跑得通，那这两个函数都不应该出问题，但是数组出问题是很正常的啊\n\tType* operator[](const int row)\n\t{\n\t\tif (row >= rows || row < 0)\n\t\t{\n\t\t\tstd::cerr << "ERROR:数组访问越界,已自动返回空指针" << endl;\n\t\t\treturn NULL;\n\t\t}\n\t\telse\n\t\t\treturn pointer[row];\n\t}\n\n\t//推荐使用函数操作符访问矩阵元素\n\tType& operator()(const int row, const int col)\n\t{\n\t\tif (row >= rows || row < 0 || col >= cols || col<0)\n\t\t{\n\t\t\tstd::cerr << "ERROR:数组访问越界,已自动返回数组元素[0][0]的引用，请检查程序是否出错" << endl;\n\t\t\treturn pointer[0][0];\n\t\t}\n\t\telse\n\t\t\treturn pointer[row][col];\n\t}\n\n\t//析构函数\n\t~Matrix()\n\t{\n\t\tclean();\n\t}\n\n\tMatrix<Type>& operator=(Matrix<Type>& other)\n\t{\n\t\tCopy(other);\n\t\treturn *this;\n\t}\n\n};\n')])])])])},[],!1,null,null,null);n.default=e.exports}}]);